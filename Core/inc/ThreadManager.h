////////////////////////////////////////////////////////////
/** @file ThreadManager.h
 *  @ingroup Thread
 *
 *  @author Luk2010
 *  @version 0.1A
 *
 *  @date 06/04/2013
 *
 *  Defines the ThreadManager class.
 *
**/
////////////////////////////////////////////////////////////
#ifndef APRO_THREADMANAGER_H
#define APRO_THREADMANAGER_H

#include "List.h"
#include "Thread.h"
#include "ThreadCondition.h"
#include "ThreadMutex.h"

namespace APro
{
    ////////////////////////////////////////////////////////////
    /** @class ThreadManager
     *  @ingroup Thread
     *  @brief Manages every Thread, Condition and Mutex active
     *  in the engine.
     *  @details It helps other class to get Condition or Mutex or even
     *  Thread easily.
     *  @note You must create condition, mutex and thread
     *  by calling ThreadManager::create*(Thread, Condition or
     *  Mutex). More, Ids are generated by the manager.
     *  @note You should use the Macros defined to create, destroy
     *  and defines the conditions and mutexs you need.
    **/
    ////////////////////////////////////////////////////////////
    class APRO_DLL ThreadManager
    {

        APRO_DECLARE_SHAREDPOINTER_CLASS_TYPEDEF(ThreadManager)

    public:

        ////////////////////////////////////////////////////////////
        /** Default constructor.
        **/
        ////////////////////////////////////////////////////////////
        ThreadManager();

        ////////////////////////////////////////////////////////////
        /** Destructor.
        **/
        ////////////////////////////////////////////////////////////
        ~ThreadManager();

    public:

        ////////////////////////////////////////////////////////////
        /** Creates a Thread with given name.
         *  @note This thread isn't running yet. You must use
         *  Thread::run function to start it.
         *  @note If the thread already exists, it returns it.
         *  @param name : Name of the Thread.
         *  @return Pointer to the Thread created. NULL if no thread
         *  could be created.
        **/
        ////////////////////////////////////////////////////////////
        Thread::ptr createThread(const String& name);

        ////////////////////////////////////////////////////////////
        /** Creates a ThreadCondition and generate an id.
         *  @return Pointer to the Condition created.
        **/
        ////////////////////////////////////////////////////////////
        ThreadCondition::ptr createCondition();

        ////////////////////////////////////////////////////////////
        /** Creates a mutex and generate an id.
         *  @return Pointer to the created Mutex.
        **/
        ////////////////////////////////////////////////////////////
        ThreadMutex::ptr createMutex();

        ////////////////////////////////////////////////////////////
        /** Destroy given thread. Stop it if it is running.
         *  @param thread : Thread to destroy
        **/
        ////////////////////////////////////////////////////////////
        void destroyThread(const String& thread);

        ////////////////////////////////////////////////////////////
        /** Destroy given thread. Stop it if it is running.
         *  @param thread : Thread to destroy
        **/
        ////////////////////////////////////////////////////////////
        void destroyThread(Thread::ptr thread);

        ////////////////////////////////////////////////////////////
        /** Destroy given condition. Signal it in case it was blocking
         *  other threads.
         *  @param cid : The Id of the condition to destroy.
        **/
        ////////////////////////////////////////////////////////////
        void destroyCondition(Id cid);

        ////////////////////////////////////////////////////////////
        /** Destroy given condition. Signal it in case it was blocking
         *  other threads.
         *  @param condition : The condition to destroy.
        **/
        ////////////////////////////////////////////////////////////
        void destroyCondition(ThreadCondition::ptr condition);

        ////////////////////////////////////////////////////////////
        /** Destroy given mutex. Unlock it before.
         *  @param mid : Id of the mutex to destroy.
        **/
        ////////////////////////////////////////////////////////////
        void destroyMutex(Id mid);

        ////////////////////////////////////////////////////////////
        /** Destroy given mutex. Unlock it before.
         *  @param mutex : The mutex to destroy.
        **/
        ////////////////////////////////////////////////////////////
        void destroyMutex(ThreadMutex::ptr mutex);

        ////////////////////////////////////////////////////////////
        /** Stop every thread currently running.
         *  @note This function wait for every events to finish, but
         *  with a timeout. If the timeout is over, it terminate the
         *  thread.
        **/
        ////////////////////////////////////////////////////////////
        void stopAllThreads();

        ////////////////////////////////////////////////////////////
        /** Terminate every thread currently running.
         *  @warning This function is not safe cause it terminate
         *  every thread using Thread::terminate.
         *  @sa Thread::terminate
        **/
        ////////////////////////////////////////////////////////////
        void terminateAllThreads();

        ////////////////////////////////////////////////////////////
        /** Destroy every threads, conditions and mutex.
         *  @note It use the stopAllThreads method to destroy the
         *  threads.
        **/
        ////////////////////////////////////////////////////////////
        void clear();

        ////////////////////////////////////////////////////////////
        /** Tell if a Thread exists.
         *  @param name : Name of the Thread
         *  @return Thread exists ?
        **/
        ////////////////////////////////////////////////////////////
        bool threadExists(const String& name);

        ////////////////////////////////////////////////////////////
        /** Tell if a condition exists.
         *  @param cid : Id of the condition
         *  @return Condition exists ?
        **/
        ////////////////////////////////////////////////////////////
        bool conditionExist(Id cid);

        ////////////////////////////////////////////////////////////
        /** Tell if a mutex exists.
         *  @param mid : Id of the mutex
         *  @return Mutex exists ?
        **/
        ////////////////////////////////////////////////////////////
        bool mutexExist(Id mid);

        ////////////////////////////////////////////////////////////
        /** Returns the thread wich has given name.
         *  @param name : Name of the thread.
         *  @return A pointer to the thread. It is null if no thread
         *  has been found.
        **/
        ////////////////////////////////////////////////////////////
        Thread::ptr getThread(const String& name);

        ////////////////////////////////////////////////////////////
        /** Returns the condition wich has given ID.
         *  @param cid : ID of the condition.
         *  @return A pointer to the condition. It is null if no condition
         *  has been found.
        **/
        ////////////////////////////////////////////////////////////
        ThreadCondition::ptr getCondition(Id cid);

        ////////////////////////////////////////////////////////////
        /** Returns the mutex wich has given ID.
         *  @param mid : ID of the mutex.
         *  @return A pointer to the mutex. It is null if no mutex
         *  has been found.
        **/
        ////////////////////////////////////////////////////////////
        ThreadMutex::ptr getMutex(Id mid);

        ////////////////////////////////////////////////////////////
        /** Removes the condition identified by given ID.
         *  @param cid : ID of the condition.
        **/
        ////////////////////////////////////////////////////////////
        void removeCondition(Id cid);

        ////////////////////////////////////////////////////////////
        /** Removes the given condition.
         *  @param condition : Pointer to the condition to remove.
        **/
        ////////////////////////////////////////////////////////////
        void removeCondition(ThreadCondition::ptr condition);

        ////////////////////////////////////////////////////////////
        /** Removes the mutex identified by given ID.
         *  @param mid : ID of the mutex.
        **/
        ////////////////////////////////////////////////////////////
        void removeMutex(Id mid);

        ////////////////////////////////////////////////////////////
        /** Removes the given mutex.
         *  @param mutex : Pointer to the mutex to remove.
        **/
        ////////////////////////////////////////////////////////////
        void removeMutex(ThreadMutex::ptr mutex);

        ////////////////////////////////////////////////////////////
        /** Signal the given condition.
         *  @param cid : Id fo the condition.
        **/
        ////////////////////////////////////////////////////////////
        void signal(Id cid);

        ////////////////////////////////////////////////////////////
        /** Signal the given condition.
         *  @param condition : Pointer to the condition.
        **/
        ////////////////////////////////////////////////////////////
        void signal(ThreadCondition::ptr condition);

        ////////////////////////////////////////////////////////////
        /** Wait for a condition.
         *  @note If timeout is negativ, use the non-timeout funcion.
         *  @param cid : Id of the condition
         *  @param mid : Id of the mutex
         *  @param timeout : Maximum time to wait.
        **/
        ////////////////////////////////////////////////////////////
        void wait(Id cid, Id mid, int timeout = -1);

        ////////////////////////////////////////////////////////////
        /** Wait for a condition.
         *  @note If timeout is negativ, use the non-timeout funcion.
         *  @param condition : The condition
         *  @param mutex : The mutex
         *  @param timeout : Maximum time to wait.
        **/
        ////////////////////////////////////////////////////////////
        void wait(ThreadCondition::ptr condition, ThreadMutex::ptr mutex, int timeout = -1);

        ////////////////////////////////////////////////////////////
        /** Lock given mutex.
         *  @param mid : ID of the mutex.
        **/
        ////////////////////////////////////////////////////////////
        void lock(Id mid);

        ////////////////////////////////////////////////////////////
        /** Lock given mutex.
         *  @param mutex : The mutex.
        **/
        ////////////////////////////////////////////////////////////
        void lock(ThreadMutex::ptr mutex);

        ////////////////////////////////////////////////////////////
        /** Unlock given mutex.
         *  @param mid : ID of the mutex.
        **/
        ////////////////////////////////////////////////////////////
        void unlock(Id mid);

        ////////////////////////////////////////////////////////////
        /** Unlock given mutex.
         *  @param mutex : The mutex.
        **/
        ////////////////////////////////////////////////////////////
        void unlock(ThreadMutex::ptr mutex);

    protected:

        typedef List<Thread::ptr>          ThreadList;    ///< List of threads.
        typedef List<ThreadCondition::ptr> ConditiosnList;///< List of conditions.
        typedef List<ThreadMutex::ptr>     MutexsList;    ///< List of mutexs.

    protected:

        ThreadList     threads;    ///< Threads created.
        ConditiosnList conditions; ///< Conditions created.
        MutexsList     mutexs;     ///< Mutexs created.
        bool           initialized;///< ThreadManager mutexs initialized ?
        ThreadMutex::ptr thread_mutex;///< Thread Manager mutex for threads.
        ThreadMutex::ptr condition_mutex;///< Thread Manager mutex for conditions.
        ThreadMutex::ptr mutex_mutex;///< Thread Manager mutex for mutexs.

    protected:

        ////////////////////////////////////////////////////////////
        /** Create mutexs for threads, conditions and mutexs.
         *  @internal
        **/
        ////////////////////////////////////////////////////////////
        void create_mutexs();

        ////////////////////////////////////////////////////////////
        /** Lock the Thread mutex.
         *  @internal
        **/
        ////////////////////////////////////////////////////////////
        void lock_threads();

        ////////////////////////////////////////////////////////////
        /** Lock the conditions mutex.
         *  @internal
        **/
        ////////////////////////////////////////////////////////////
        void lock_conditions();

        ////////////////////////////////////////////////////////////
        /** Lock the mutexs mutex.
         *  @internal
        **/
        ////////////////////////////////////////////////////////////
        void lock_mutexs();

        ////////////////////////////////////////////////////////////
        /** Lock the three mutexs.
         *  @internal
        **/
        ////////////////////////////////////////////////////////////
        void lock_everything();

        ////////////////////////////////////////////////////////////
        /** Unlock the Thread mutex.
         *  @internal
        **/
        ////////////////////////////////////////////////////////////
        void unlock_threads();

        ////////////////////////////////////////////////////////////
        /** Unlock the conditions mutex.
         *  @internal
        **/
        ////////////////////////////////////////////////////////////
        void unlock_conditions();

        ////////////////////////////////////////////////////////////
        /** Unlock the mutexs mutex.
         *  @internal
        **/
        ////////////////////////////////////////////////////////////
        void unlock_mutexs();

        ////////////////////////////////////////////////////////////
        /** Unlock every mutexs.
         *  @internal
        **/
        ////////////////////////////////////////////////////////////
        void unlock_everything();

        ////////////////////////////////////////////////////////////
        /** Destroys the three mutexs.
         *  @internal
        **/
        ////////////////////////////////////////////////////////////
        void destroy_mutexs();

    public:

        static ThreadManager* currentThreadManager;///< Current Thread Manager. This object is setted by the Main object at initialization.

        ////////////////////////////////////////////////////////////
        /** Return the current Thread Manager.
         *  @note The current thread manager is setted by the Main
         *  object, at initialization. So, before initialization,
         *  you can't use the ThreadManager.
         *  @return The Thread Manager.
        **/
        ////////////////////////////////////////////////////////////
        static ThreadManager& get();

    protected:

        ////////////////////////////////////////////////////////////
        /** Generates an ID for next Mutex or Condition. This ID
         *  is unique.
         *  @internal
         *  @return Newly generated ID. If 0, id is invalid.
        **/
        ////////////////////////////////////////////////////////////
        Id generateID();

    };

    ////////////////////////////////////////////////////////////
    /** @addtogroup Thread
     *
     *  @{
    **/
    ////////////////////////////////////////////////////////////

    #define APRO_THREAD_MUTEX(m)           ThreadMutex::ptr m                                       ///< Defines a mutex.
    #define APRO_THREAD_MUTEX_CREATE(m)    m = ThreadManager::get().createMutex()                   ///< Create a mutex.
    #define APRO_THREAD_MUTEX_DESTROY(m)   ThreadManager::get().destroyMutex(m)                     ///< Destroy a mutex.
    #define APRO_THREAD_MUTEX_LOCK(m)      ThreadManager::get().lock(m)                             ///< Lock a mutex.
    #define APRO_THREAD_MUTEX_UNLOCK(m)    ThreadManager::get().unlock(m)                           ///< Unlock a mutex.

    ////////////////////////////////////////////////////////////
    /** @brief Lock a mutex if exists. Otherwise, creates one and
     *  locks it if creation successfull.
    **/
    ////////////////////////////////////////////////////////////
    void APRO_THREAD_MUTEX_SAFELOCK(ThreadMutex::ptr& mutex);

    ////////////////////////////////////////////////////////////
    /** @brief Unlock a mutex if exists. Otherwise, creates one.
    **/
    ////////////////////////////////////////////////////////////
    void APRO_THREAD_MUTEX_SAFEUNLOCK(ThreadMutex::ptr& mutex);

    #define APRO_THREAD_CONDITION(c)                    ThreadCondition::ptr c                      ///< Defines a condition.
    #define APRO_THREAD_CONDITION_CREATE(c)             c = ThreadManager::get().createCondition()  ///< Create a condition.
    #define APRO_THREAD_CONDITION_DESTROY(c)            ThreadManager::get().destroyCondition(c)    ///< Destroy a condition.
    #define APRO_THREAD_CONDITION_SIGNAL(c)             ThreadManager::get().signal(c)              ///< Signal the condition.
    #define APRO_THREAD_CONDITION_WAIT(c, m)            ThreadManager::get().wait(c, m)             ///< Wait for the condition.
    #define APRO_THREAD_CONDITION_WAITTIMEOUT(c, m, t)  ThreadManager::get().wait(c, m, t)          ///< Wait for the condition with timeout.

    ////////////////////////////////////////////////////////////
    /** @}
    **/
    ////////////////////////////////////////////////////////////
}

#endif // APRO_THREADMANAGER_H
